input {
  # Beats input
  beats {
    port => 5044
    codec => json
  }

  # HTTP input for direct log shipping
  http {
    port => 8080
    codec => json
  }

  # Syslog input
  syslog {
    port => 5000
    type => "syslog"
  }
}

filter {
  # Parse JSON logs
  if [message] =~ /^\{.*\}$/ {
    json {
      source => "message"
      remove_field => ["message"]
    }
  }

  # Add environment tags
  mutate {
    add_field => {
      "[@metadata][environment]" => "${ENVIRONMENT:production}"
    }
  }

  # Parse timestamp
  date {
    match => [ "timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss", "yyyy/MM/dd HH:mm:ss" ]
    target => "@timestamp"
  }

  # Geoip for IP addresses
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }

  # User agent parsing
  if [user_agent] {
    useragent {
      source => "user_agent"
      target => "ua"
    }
  }

  # Extract log level
  if [level] {
    mutate {
      uppercase => [ "level" ]
    }
  }

  # Add Kubernetes metadata if available
  if [kubernetes] {
    mutate {
      rename => {
        "[kubernetes][pod][name]" => "pod_name"
        "[kubernetes][namespace]" => "namespace"
        "[kubernetes][container][name]" => "container_name"
      }
    }
  }

  # Categorize by service
  if [service] =~ "server" {
    mutate {
      add_tag => ["backend", "api"]
    }
  } else if [service] =~ "client" {
    mutate {
      add_tag => ["frontend"]
    }
  } else if [service] =~ "mongodb" {
    mutate {
      add_tag => ["database", "mongodb"]
    }
  } else if [service] =~ "redis" {
    mutate {
      add_tag => ["cache", "redis"]
    }
  }

  # Error detection
  if [level] == "ERROR" or [level] == "FATAL" {
    mutate {
      add_tag => ["error"]
      add_field => {
        "alert" => "true"
      }
    }
  }

  # Performance metrics
  if [duration_ms] {
    ruby {
      code => "
        duration = event.get('duration_ms').to_f
        if duration > 1000
          event.set('performance_category', 'slow')
        elsif duration > 500
          event.set('performance_category', 'medium')
        else
          event.set('performance_category', 'fast')
        end
      "
    }
  }

  # HTTP status code categorization
  if [status_code] {
    if [status_code] >= 500 {
      mutate {
        add_tag => ["error", "server_error"]
      }
    } else if [status_code] >= 400 {
      mutate {
        add_tag => ["client_error"]
      }
    } else if [status_code] >= 200 and [status_code] < 300 {
      mutate {
        add_tag => ["success"]
      }
    }
  }

  # Remove unnecessary fields
  mutate {
    remove_field => ["agent", "ecs", "host", "input", "log"]
  }
}

output {
  # Output to Elasticsearch
  elasticsearch {
    hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
    index => "tepslab-%{[@metadata][environment]}-%{+YYYY.MM.dd}"
    user => "${ELASTICSEARCH_USER:elastic}"
    password => "${ELASTICSEARCH_PASSWORD:changeme}"
  }

  # Output errors to separate index
  if "error" in [tags] {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
      index => "tepslab-errors-%{+YYYY.MM.dd}"
      user => "${ELASTICSEARCH_USER:elastic}"
      password => "${ELASTICSEARCH_PASSWORD:changeme}"
    }
  }

  # Debug output (optional)
  if [@metadata][debug] {
    stdout {
      codec => rubydebug
    }
  }
}
